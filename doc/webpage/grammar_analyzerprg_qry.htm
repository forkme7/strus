<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 2.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
	<link rel="icon" type="image/ico" href="images/strus.ico" />
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<meta name="description" content="Query analyzer program of strus, a collection of C++ libraries for building a full-text search engine." />
	<meta name="keywords" content="fulltext search engine C++" />
	<meta name="author" content="Patrick Frey &lt;patrickpfrey (a) yahoo (dt) com&gt;" />
	<link rel="stylesheet" type="text/css" href="text-profile.css" title="Text Profile" media="all" />
	<title>Strus query analyzer configuration source</title>
</head>

<body><div id="wrap">
<div id="content">
	<h1>Strus query analyzer configuration</h1>
	<h2>Language grammar</h2>
	<p class="description">The following grammar (as EBNF) is the formal language for 
	configuration used by the strus utilities (strusUtilities) for describing query phrase
	analysis.
	</p>
	<h3>Comments</h3>
	<p class="description">
		Comments are starting with <b>#</b> and are reaching to the end of the line.
		Using <b>#</b> as part of a symbol is possible if it is part of a single or double
		quoted string.
	</p>
	<h3>Handling of spaces</h3>
	<p class="description">
	Spaces, control characters and end of lines have no meaning in the language.
	</p>
	<h3>Case sensivity/insensivity</h3>
	<p class="description">
	Keywords and identifiers referring to elements in the storage are case insensitive.
	So are function names of tokenizers and normalizers.
	</p>
	<h3>EBNF</h3>
	<pre>
IDENTIFIER     : [A-Za-z][A-Za-z0-9_]*
STRING         : &lt;single or double quoted string with backslash escaping&gt;

config         = definitionlist
               ;
definitionlist = definition definitionlist
               |
               ;
definition     = type [ "/" phrasetype ] =" normalizer tokenizer selector ";"
               ;
type           = IDENTIFIER ;
normalizer     = functioncall ":" normalizer
               | functioncall
               ;
tokenizer      = functioncall
               ;
functioncall   = functionname "(" argumentlist ")" ;
               | functionname
               ;
functionname   = IDENTIFIER ;
argumentlist   = argument "," argumentlist
               |
               ;
argument       = IDENTIFIER
               | STRING
               ;
selector       = EXPRESSION ;
	</pre>
	<h3>Meaning of the grammar elements</h3>
	<h5>phrasetype</h5>
	<p class="description">Identifier used for addressing this query phrase analysis method.
	</p>
	<h5>type</h5>
	<p class="description">Type of feature or element name assigned to this definition result.
	If no "phrasetype" is specified then the "phrasetype" is defined to be the same as
	the "type" identifier.
	</p>
	<h5>functionname</h5>
	<p class="description">Name of the function that identifier this tokenizer or normalizer.</p>
	<h5>selector</h5>
	<p class="description">The selector expression defines what document segments are used to produce the resulting feature or element.
	</p>
	<h3>Example</h3>
	<pre>
stem = lc:convdia(en):stem(en):dictmap("irregular_verbs_en.txt"):lc word;
	</pre>
</div>
</div>
</body>
</html>

