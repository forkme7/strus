<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 2.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
	<link rel="icon" type="image/ico" href="images/strus.ico" />
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<meta name="description" content="Description of the command line utility programs of strus, a collection of C++ libraries for building a full-text search engine." />
	<meta name="keywords" content="fulltext search engine C++" />
	<meta name="author" content="Patrick Frey &lt;patrickpfrey (a) yahoo (dt) com&gt;" />
	<link rel="stylesheet" type="text/css" href="text-profile.css" title="Text Profile" media="all" />
	<title>Strus utility programs</title>
</head>
<body>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-63809026-12', 'auto');
  ga('send', 'pageview');
</script>
<div id="wrap">
	<div id="content">
		<h1>Command line utility programs</h1>
		<p class="description">This document lists some utility programs with description,
		most of them are implemented in the project <a href="https://github.com/patrickfrey/strusUtilities">strusUtilities</a>.
		Some of these programs use domain specific language for their input description. You find
		the list of languages <a href="utilities_lang.htm">here</a>.
		</p>
		<h2>List of utility programs</h2>
<ul>
<a name="strusCreate"></a><li><b>strusCreate</b>
<br/>Create a strus storage. (implemented in the project <a href="https://github.com/patrickfrey/strusUtilities">strusUtilities</a>)
<input class="toggle-box" id="strusCreate_usage" type="checkbox" >
<label for="strusCreate_usage">Usage</label>
<pre>
usage: strusCreate [options]
description: Creates a storage with its key value store database.
options:
-h|--help
    Print this usage and do nothing else
-v|--version
    Print the program version and do nothing else
-m|--module &lt;MOD&gt;
    Load components from module &lt;MOD&gt;
-M|--moduledir &lt;DIR&gt;
    Search modules to load first in &lt;DIR&gt;
-s|--storage &lt;CONFIG&gt;
    Define the storage configuration string as &lt;CONFIG&gt;
    &lt;CONFIG&gt; is a semicolon ';' separated list of assignments:
            path=&lt;LevelDB storage path&gt;;compression=&lt;yes/no&gt;
            acl=&lt;yes/no, yes if users with different access rights exist&gt;
            metadata=&lt;comma separated list of meta data def&gt;
-S|--configfile &lt;FILENAME&gt;
    Define the storage configuration file as &lt;FILENAME&gt;
    &lt;FILENAME&gt; is a file containing the configuration string
</pre>
</li>

<a name="strusDestroy"></a><li><b>strusDestroy</b>
<br/>Remove a strus storage and all its files. (implemented in the project <a href="https://github.com/patrickfrey/strusUtilities">strusUtilities</a>)
<input class="toggle-box" id="strusDestroy_usage" type="checkbox" >
<label for="strusDestroy_usage">Usage</label>
<pre>
usage: strusDestroy [options]
description: Removes an existing storage database.
options:
-h|--help
    Print this usage and do nothing else
-v|--version
    Print the program version and do nothing else
-m|--module &lt;MOD&gt;
    Load components from module &lt;MOD&gt;
-M|--moduledir &lt;DIR&gt;
    Search modules to load first in &lt;DIR&gt;
-s|--storage &lt;CONFIG&gt;
    Define the storage configuration string as &lt;CONFIG&gt;
    &lt;CONFIG&gt; is a semicolon ';' separated list of assignments:
            path=&lt;LevelDB storage path&gt;
            create=&lt;yes/no, yes=do create if database does not exist yet&gt;
            cache=&lt;size of LRU cache for LevelDB&gt;
            compression=&lt;yes/no&gt;
            max_open_files=&lt;maximum number of open files for LevelDB&gt;
            write_buffer_size=&lt;Amount of data to build up in memory per file&gt;
            block_size=&lt;approximate size of user data packed per block&gt;
-S|--configfile &lt;FILENAME&gt;
    Define the storage configuration file as &lt;FILENAME&gt;
    &lt;FILENAME&gt; is a file containing the configuration string
</pre>
</li>

<a name="strusInspect"></a><li><b>strusInspect</b>
<br/>Inspect elements of items inserted in a strus storage. (implemented in the project <a href="https://github.com/patrickfrey/strusUtilities">strusUtilities</a>)
<input class="toggle-box" id="strusInspect_usage" type="checkbox" >
<label for="strusInspect_usage">Usage</label>
<pre>
usage: strusInspect [options] &lt;what...&gt;
&lt;what&gt;    : what to inspect:
            "pos" &lt;type&gt; &lt;value&gt; [&lt;doc-id/no&gt;]
               = Get the list of positions for a search index term.
                 If doc is not specified then dump value for all docs.
            "ff" &lt;type&gt; &lt;value&gt; [&lt;doc-id/no&gt;]
               = Get the feature frequency for a search index feature
                 If doc is not specified then dump value for all docs.
            "df" &lt;type&gt; &lt;value&gt;
               = Get the document frequency for a search index feature
            "ttf" &lt;type&gt; [&lt;doc-id/no&gt;]
               = Get the term type frequency in a document
                 If doc is not specified then dump value for all docs.
            "ttc" &lt;type&gt; [&lt;doc-id/no&gt;]
               = Get the term type count (distinct) in a document
                 If doc is not specified then dump value for all docs.
            "indexterms" &lt;type&gt; [&lt;doc-id/no&gt;]
               = Get the list of tuples of term value, first position and ff 
                 for a search index term type.
                 If doc is not specified then dump value for all docs.
            "nofdocs"
               = Get the number of documents in the storage
            "maxdocno"
               = Get the maximum document number allocated in the storage
            "metadata" &lt;name&gt; [&lt;doc-id/no&gt;]
               = Get the value of a meta data element
                 If doc is not specified then dump value for all docs.
            "metatable"
               = Get the schema of the meta data table
            "attribute" &lt;name&gt; [&lt;doc-id/no&gt;]
               = Get the value of a document attribute
                 If doc is not specified then dump value for all docs.
            "attrnames"
               = Get the list of all attribute names defined for the storage
            "content" &lt;type&gt; [&lt;doc-id/no&gt;]
               = Get the content of the forward index for a type
                 If doc is not specified then dump content for all docs.
            "fwstats" &lt;type&gt; [&lt;doc-id/no&gt;]
               = Get the statistis of the forward index for a type
                 If doc is not specified then dump value for all docs.
            "token" &lt;type&gt; &lt;doc-id/no&gt;
               = Get the list of terms in the forward index for a type
            "docno" &lt;docid&gt;
               = Get the internal document number for a document id
description: Inspect some data in the storage.
options:
-h|--help
    Print this usage and do nothing else
-v|--version
    Print the program version and do nothing else
-m|--module &lt;MOD&gt;
    Load components from module &lt;MOD&gt;
-M|--moduledir &lt;DIR&gt;
    Search modules to load first in &lt;DIR&gt;
-r|--rpc &lt;ADDR&gt;
    Execute the command on the RPC server specified by &lt;ADDR&gt;
-s|--storage &lt;CONFIG&gt;
    Define the storage configuration string as &lt;CONFIG&gt;
    &lt;CONFIG&gt; is a semicolon ';' separated list of assignments:
            path=&lt;LevelDB storage path&gt;
            create=&lt;yes/no, yes=do create if database does not exist yet&gt;
            cache=&lt;size of LRU cache for LevelDB&gt;
            compression=&lt;yes/no&gt;
            max_open_files=&lt;maximum number of open files for LevelDB&gt;
            write_buffer_size=&lt;Amount of data to build up in memory per file&gt;
            block_size=&lt;approximate size of user data packed per block&gt;
            cachedterms=&lt;file with list of terms to cache&gt;
</pre>
</li>

<a name="strusAnalyze"></a><li><b>strusAnalyze</b>
<br/>Dump the document analyze result without feeding the storage. This program can be used to check the result of the document analysis.
(implemented in the project <a href="https://github.com/patrickfrey/strusUtilities">strusUtilities</a>)
<input class="toggle-box" id="strusAnalyze_usage" type="checkbox" >
<label for="strusAnalyze_usage">Usage</label>
<pre>
usage: strusAnalyze [options] &lt;program&gt; &lt;document&gt;
&lt;program&gt;   = path of analyzer program
&lt;document&gt;  = path of document to analyze ('-' for stdin)
description: Analyzes a document and dumps the result to stdout.
options:
-h|--help
    Print this usage and do nothing else
-v|--version
    Print the program version and do nothing else
-m|--module &lt;MOD&gt;
    Load components from module &lt;MOD&gt;
-M|--moduledir &lt;DIR&gt;
    Search modules to load first in &lt;DIR&gt;
-R|--resourcedir &lt;DIR&gt;
    Search resource files for analyzer first in &lt;DIR&gt;
-g|--segmenter &lt;NAME&gt;
    Use the document segmenter with name &lt;NAME&gt; (default textwolf XML)
-r|--rpc &lt;ADDR&gt;
    Execute the command on the RPC server specified by &lt;ADDR&gt;
</pre>
</li>

<a name="strusAnalyzePhrase"></a><li><b>strusAnalyzePhrase</b>
<br/>Call the query analyzer with a phrase to analyze. This program can also be used to check details of the document analyzer as it tokenizes and normalizes a text segment with the tokenizer and normalizer specified.
(implemented in the project <a href="https://github.com/patrickfrey/strusUtilities">strusUtilities</a>)
<input class="toggle-box" id="strusAnalyzePhrase_usage" type="checkbox" >
<label for="strusAnalyzePhrase_usage">Usage</label>
<pre>
usage: strusAnalyze [options] &lt;phrasepath&gt;
&lt;phrasepath&gt; = path to phrase to analyze ('-' for stdin)
description: tokenizes and normalizes a text segment
             and prints the result to stdout.
options:
-h|--help
   Print this usage and do nothing else
-v|--version
    Print the program version and do nothing else
-m|--module &lt;MOD&gt;
    Load components from module &lt;MOD&gt;
-M|--moduledir &lt;DIR&gt;
    Search modules to load first in &lt;DIR&gt;
-R|--resourcedir &lt;DIR&gt;
    Search resource files for analyzer first in &lt;DIR&gt;
-t|--tokenizer &lt;CALL&gt;
    Use the tokenizer &lt;CALL&gt; (default 'content')
-n|--normalizer &lt;CALL&gt;
    Use the normalizer &lt;CALL&gt; (default 'orig')
-q|--quot &lt;STR&gt;
    Use the string &lt;STR&gt; as quote for the result (default "'")
-p|--plain
    Do not print position and define default quotes as empty
</pre>
</li>

<a name="strusSegment"></a><li><b>strusSegment</b>
<br/>Call the segmenter with a document and one or more expressions to exract with the segmenter. Dump the resulting segments to stdout.
(implemented in the project <a href="https://github.com/patrickfrey/strusUtilities">strusUtilities</a>)
<input class="toggle-box" id="strusSegment_usage" type="checkbox" >
<label for="strusSegment_usage">Usage</label>
<pre>
usage: strusSegment [options] &lt;document&gt;
&lt;document&gt;  = path to document to segment ('-' for stdin)
description: Segments a document with the expressions (-e) specified
             and dumps the resulting segments to stdout.
options:
-h|--help
    Print this usage and do nothing else
-v|--version
    Print the program version and do nothing else
-m|--module &lt;MOD&gt;
    Load components from module &lt;MOD&gt;
-M|--moduledir &lt;DIR&gt;
    Search modules to load first in &lt;DIR&gt;
-s|--segmenter &lt;NAME&gt;
    Use the document segmenter with name &lt;NAME&gt; (default textwolf XML)
-e|--expression &lt;EXPR&gt;
    Use the expression &lt;EXPR&gt; to select documents (default '//()')
-i|--index
    Print the indices of the expressions matching as prefix with ':'
-p|--position
    Print the positions of the expressions matching as prefix
-q|--quot &lt;STR&gt;
    Use the string &lt;STR&gt; as quote for the result (default "'")
-P|--prefix &lt;STR&gt;
    Use the string &lt;STR&gt; as prefix for the result
-E|--esceol
    Escape end of line with space
</pre>
</li>

<a name="strusInsert"></a><li><b>strusInsert</b>
<br/>Insert a document or all files in a directory or in any descendant directory of it.
(implemented in the project <a href="https://github.com/patrickfrey/strusUtilities">strusUtilities</a>)
<input class="toggle-box" id="strusInsert_usage" type="checkbox" >
<label for="strusInsert_usage">Usage</label>
<pre>
usage: strusInsert [options] &lt;program&gt; &lt;docpath&gt;
&lt;program&gt; = path of analyzer program or analyzer map program
&lt;docpath&gt; = path of document or directory to insert
description: Insert a document or a set of documents into a storage.
options:
-h|--help
    Print this usage and do nothing else
-v|--version
    Print the program version and do nothing else
-s|--storage &lt;CONFIG&gt;
    Define the storage configuration string as &lt;CONFIG&gt;
    &lt;CONFIG&gt; is a semicolon ';' separated list of assignments:
            path=&lt;LevelDB storage path&gt;
            create=&lt;yes/no, yes=do create if database does not exist yet&gt;
            cache=&lt;size of LRU cache for LevelDB&gt;
            compression=&lt;yes/no&gt;
            max_open_files=&lt;maximum number of open files for LevelDB&gt;
            write_buffer_size=&lt;Amount of data to build up in memory per file&gt;
            block_size=&lt;approximate size of user data packed per block&gt;
            cachedterms=&lt;file with list of terms to cache&gt;
-S|--configfile &lt;FILENAME&gt;
    Define the storage configuration file as &lt;FILENAME&gt;
    &lt;FILENAME&gt; is a file containing the configuration string
-m|--module &lt;MOD&gt;
    Load components from module &lt;MOD&gt;
-M|--moduledir &lt;DIR&gt;
    Search modules to load first in &lt;DIR&gt;
-R|--resourcedir &lt;DIR&gt;
    Search resource files for analyzer first in &lt;DIR&gt;
-r|--rpc &lt;ADDR&gt;
    Execute the command on the RPC server specified by &lt;ADDR&gt;
-g|--segmenter &lt;NAME&gt;
    Use the document segmenter with name &lt;NAME&gt; (default textwolf)
-x|--extension &lt;EXT&gt;
    Grab only the files with extension &lt;EXT&gt; (default all files)
-t|--threads &lt;N&gt;
    Set &lt;N&gt; as number of inserter threads to use
-c|--commit &lt;N&gt;
    Set &lt;N&gt; as number of documents inserted per transaction (default 1000)
-f|--fetch &lt;N&gt;
    Set &lt;N&gt; as number of files fetched in each inserter iteration
    Default is the value of option '--commit' (one document/file)
-L|--logerror &lt;FILE&gt;
    Write the last error occurred to &lt;FILE&gt; in case of an exception
-V|--verbose
    verbose output
</pre>
</li>

<a name="strusUpdateStorage"></a><li><b>strusUpdateStorage</b>
<br/>This program allows to update attributes, meta data and user access rights in a storage from a batch file.
(implemented in the project <a href="https://github.com/patrickfrey/strusUtilities">strusUtilities</a>)
<input class="toggle-box" id="strusUpdateStorage_usage" type="checkbox" >
<label for="strusUpdateStorage_usage">Usage</label>
<pre>
usage: strusUpdateStorage [options] &lt;updatefile&gt;
&lt;updatefile&gt;  = file with the batch of updates ('-' for stdin)
description: Executes a batch of updates of attributes, meta data
             or user rights in a storage.
options:
-h|--help
    Print this usage and do nothing else
-v|--version
    Print the program version and do nothing else
-m|--module &lt;MOD&gt;
    Load components from module &lt;MOD&gt;
-M|--moduledir &lt;DIR&gt;
    Search modules to load first in &lt;DIR&gt;
-r|--rpc &lt;ADDR&gt;
    Execute the command on the RPC server specified by &lt;ADDR&gt;
-s|--storage &lt;CONFIG&gt;
    Define the storage configuration string as &lt;CONFIG&gt;
    &lt;CONFIG&gt; is a semicolon ';' separated list of assignments:
            path=&lt;LevelDB storage path&gt;
            create=&lt;yes/no, yes=do create if database does not exist yet&gt;
            cache=&lt;size of LRU cache for LevelDB&gt;
            compression=&lt;yes/no&gt;
            max_open_files=&lt;maximum number of open files for LevelDB&gt;
            write_buffer_size=&lt;Amount of data to build up in memory per file&gt;
            block_size=&lt;approximate size of user data packed per block&gt;
            cachedterms=&lt;file with list of terms to cache&gt;
-a|--attribute &lt;NAME&gt;
    The update batch is a list of attributes assignments
    The name of the updated attribute is &lt;NAME&gt;.
-m|--metadata &lt;NAME&gt;
    The update batch is a list of meta data assignments.
    The name of the updated meta data element is &lt;NAME&gt;.
-u|--useraccess
    The update batch is a list of user right assignments.
-c|--commit &lt;N&gt;
    Set &lt;N&gt; as number of updates per transaction (default 10000)
    If &lt;N&gt; is set to 0 then only one commit is done at the end
-L|--logerror &lt;FILE&gt;
    Write the last error occurred to &lt;FILE&gt; in case of an exception
</pre>
</li>

<a name="strusCheckStorage"></a><li><b>strusCheckStorage</b>
<br/>This program checks a strus storage for corrupt data.
(implemented in the project <a href="https://github.com/patrickfrey/strusUtilities">strusUtilities</a>)
<input class="toggle-box" id="strusCheckStorage_usage" type="checkbox" >
<label for="strusCheckStorage_usage">Usage</label>
<pre>
usage: strusCheckStorage [options]
description: Checks a storage for corrupt data.
options:
-h|--help
    Print this usage and do nothing else
-v|--version
    Print the program version and do nothing else
-s|--storage &lt;CONFIG&gt;
    Define the storage configuration string as &lt;CONFIG&gt;
    &lt;CONFIG&gt; is a semicolon ';' separated list of assignments:
            path=&lt;LevelDB storage path&gt;
            create=&lt;yes/no, yes=do create if database does not exist yet&gt;
            cache=&lt;size of LRU cache for LevelDB&gt;
            compression=&lt;yes/no&gt;
            max_open_files=&lt;maximum number of open files for LevelDB&gt;
            write_buffer_size=&lt;Amount of data to build up in memory per file&gt;
            block_size=&lt;approximate size of user data packed per block&gt;
            cachedterms=&lt;file with list of terms to cache&gt;
-e|--exists
    Checks if the database of the storage exists and return 'yes'/'no'
-m|--module &lt;MOD&gt;
    Load components from module &lt;MOD&gt;
-M|--moduledir &lt;DIR&gt;
    Search modules to load first in &lt;DIR&gt;
-r|--rpc &lt;ADDR&gt;
    Execute the commands on the RPC server specified by &lt;ADDR&gt;
</pre>
</li>

<a name="strusCheckInsert"></a><li><b>strusCheckInsert</b>
<br/>Processes the documents the same way as strusInsert. But instead of inserting the documents,
it checks if the document representation in the storage is complete compared with the checked documents.
(implemented in the project <a href="https://github.com/patrickfrey/strusUtilities">strusUtilities</a>)
<input class="toggle-box" id="strusCheckInsert_usage" type="checkbox" >
<label for="strusCheckInsert_usage">Usage</label>
<pre>
usage: strusCheckInsert [options] &lt;program&gt; &lt;docpath&gt;
&lt;program&gt; = path of analyzer program or analyzer map program
&lt;docpath&gt; = path of document or directory to check
description: Checks if a storage contains all data of a document set.
options:
-h|--help
    Print this usage and do nothing else
-v|--version
    Print the program version and do nothing else
-s|--storage &lt;CONFIG&gt;
    Define the storage configuration string as &lt;CONFIG&gt;
    &lt;CONFIG&gt; is a semicolon ';' separated list of assignments:
            path=&lt;LevelDB storage path&gt;
            create=&lt;yes/no, yes=do create if database does not exist yet&gt;
            cache=&lt;size of LRU cache for LevelDB&gt;
            compression=&lt;yes/no&gt;
            max_open_files=&lt;maximum number of open files for LevelDB&gt;
            write_buffer_size=&lt;Amount of data to build up in memory per file&gt;
            block_size=&lt;approximate size of user data packed per block&gt;
            cachedterms=&lt;file with list of terms to cache&gt;
-S|--configfile &lt;FILENAME&gt;
    Define the storage configuration file as &lt;FILENAME&gt;
    &lt;FILENAME&gt; is a file containing the configuration string
-m|--module &lt;MOD&gt;
    Load components from module &lt;MOD&gt;
-M|--moduledir &lt;DIR&gt;
    Search modules to load first in &lt;DIR&gt;
-R|--resourcedir &lt;DIR&gt;
    Search resource files for analyzer first in &lt;DIR&gt;
-r|--rpc &lt;ADDR&gt;
    Execute the command on the RPC server specified by &lt;ADDR&gt;
-g|--segmenter &lt;NAME&gt;
    Use the document segmenter with name &lt;NAME&gt; (default textwolf XML)
-x|--extension &lt;EXT&gt;
    Grab only the files with extension &lt;EXT&gt; (default all files)
-t|--threads &lt;N&gt;
    Set &lt;N&gt; as number of inserter threads to use
-l|--logfile &lt;FILE&gt;
    Set &lt;FILE&gt; as output file (default stdout)
-n|--notify &lt;N&gt;
    Set &lt;N&gt; as notification interval (number of documents)
</pre>
</li>

<a name="strusQuery"></a><li><b>strusQuery</b>
<br/>Evaluate a query per command line.
(implemented in the project <a href="https://github.com/patrickfrey/strusUtilities">strusUtilities</a>)
<input class="toggle-box" id="strusQuery_usage" type="checkbox" >
<label for="strusQuery_usage">Usage</label>
<pre>
usage: strusQuery [options] &lt;anprg&gt; &lt;qeprg&gt; &lt;query&gt;
&lt;anprg&gt;   = path of query analyzer program
&lt;qeprg&gt;   = path of query eval program
&lt;query&gt;   = path of query or '-' for stdin
description: Executes a query or a list of queries from a file.
options:
-h|--help
    Print this usage and do nothing else
-v|--version
    Print the program version and do nothing else
-s|--storage &lt;CONFIG&gt;
    Define the storage configuration string as &lt;CONFIG&gt;
    &lt;CONFIG&gt; is a semicolon ';' separated list of assignments:
            path=&lt;LevelDB storage path&gt;
            create=&lt;yes/no, yes=do create if database does not exist yet&gt;
            cache=&lt;size of LRU cache for LevelDB&gt;
            compression=&lt;yes/no&gt;
            max_open_files=&lt;maximum number of open files for LevelDB&gt;
            write_buffer_size=&lt;Amount of data to build up in memory per file&gt;
            block_size=&lt;approximate size of user data packed per block&gt;
            cachedterms=&lt;file with list of terms to cache&gt;
-u|--user &lt;NAME&gt;
    Use user name &lt;NAME&gt; for the query
-N|--nofranks &lt;N&gt;
    Return maximum &lt;N&gt; ranks as query result
-I|--firstrank &lt;N&gt;
    Return the result starting with rank &lt;N&gt; as first rank
-Q|--quiet
    No output of results
-T|--time
    Do print duration of pure query evaluation
-m|--module &lt;MOD&gt;
    Load components from module &lt;MOD&gt;
-M|--moduledir &lt;DIR&gt;
    Search modules to load first in &lt;DIR&gt;
-R|--resourcedir &lt;DIR&gt;
    Search resource files for analyzer first in &lt;DIR&gt;
-r|--rpc &lt;ADDR&gt;
    Execute the command on the RPC server specified by &lt;ADDR&gt;
</pre>
</li>

<a name="strusAlterMetaData"></a><li><b>strusAlterMetaData</b>
<br/>Alter the table structure for document metadata of a storage.
(implemented in the project <a href="https://github.com/patrickfrey/strusUtilities">strusUtilities</a>)
<input class="toggle-box" id="strusAlterMetaData_usage" type="checkbox" >
<label for="strusAlterMetaData_usage">Usage</label>
<pre>
usage: strusAlterMetaData [options] &lt;config&gt; &lt;cmds&gt;
&lt;config&gt;  : configuration string of the storage
            semicolon';' separated list of assignments:
            path=&lt;LevelDB storage path&gt;
            create=&lt;yes/no, yes=do create if database does not exist yet&gt;
            cache=&lt;size of LRU cache for LevelDB&gt;
            compression=&lt;yes/no&gt;
            max_open_files=&lt;maximum number of open files for LevelDB&gt;
            write_buffer_size=&lt;Amount of data to build up in memory per file&gt;
            block_size=&lt;approximate size of user data packed per block&gt;
            cachedterms=&lt;file with list of terms to cache&gt;
&lt;cmds&gt;    : semicolon separated list of commands:
            alter &lt;name&gt; &lt;newname&gt; &lt;newtype&gt;
              &lt;name&gt;    :name of the element to change
              &lt;newname&gt; :new name of the element
              &lt;newtype&gt; :new type (*) of the element
            add &lt;name&gt; &lt;type&gt;
              &lt;name&gt;    :name of the element to add
              &lt;type&gt;    :type (*) of the element to add
            delete &lt;name&gt;
              &lt;name&gt;    :name of the element to remove
            rename &lt;name&gt; &lt;newname&gt;
              &lt;name&gt;    :name of the element to rename
              &lt;newname&gt; :new name of the element
            clear &lt;name&gt;
              &lt;name&gt;    :name of the element to clear all values
(*)       :type of an element is one of the following:
              INT8      :one byte signed integer value
              UINT8     :one byte unsigned integer value
              INT16     :two bytes signed integer value
              UINT16    :two bytes unsigned integer value
              INT32     :four bytes signed integer value
              UINT32    :four bytes unsigned integer value
              FLOAT16   :two bytes floating point value (IEEE 754 small)
              FLOAT32   :four bytes floating point value (IEEE 754 single)
description: Executes a list of alter the meta data table commands.
options:
-h|--help
    Print this usage and do nothing else
-v|--version
    Print the program version and do nothing else
-m|--module &lt;MOD&gt;
    Load components from module &lt;MOD&gt;
-M|--moduledir &lt;DIR&gt;
    Search modules to load first in &lt;DIR&gt;
</pre>
</li>

<a name="strusGenerateKeyMap"></a><li><b>strusGenerateKeyMap</b>
<br/>Dumps a list of terms as result of document anaylsis of a file or directory.
The dump can be loaded by the storage on startup to create a map of frequently used terms.
(implemented in the project <a href="https://github.com/patrickfrey/strusUtilities">strusUtilities</a>)
<input class="toggle-box" id="strusGenerateKeyMap_usage" type="checkbox" >
<label for="strusGenerateKeyMap_usage">Usage</label>
<pre>
usage: strusGenerateKeyMap [options] &lt;program&gt; &lt;docpath&gt;
&lt;program&gt; = path of analyzer program  or analyzer map program
&lt;docpath&gt; = path of document or directory to insert
description: Dumps a list of terms as result of document
    anaylsis of a file or directory. The dump can be loaded by
    the storage on startup to create a map of frequently used terms.
options:
-h|--help
    Print this usage and do nothing else
-v|--version
    Print the program version and do nothing else
-m|--module &lt;MOD&gt;
    Load components from module &lt;MOD&gt;
-M|--moduledir &lt;DIR&gt;
    Search modules to load first in &lt;DIR&gt;
-R|--resourcedir &lt;DIR&gt;
    Search resource files for analyzer first in &lt;DIR&gt;
-s|--segmenter &lt;NAME&gt;
    Use the document segmenter with name &lt;NAME&gt; (default textwolf XML)
-x|--extension &lt;EXT&gt;
    Grab only the files with extension &lt;EXT&gt; (default all files)
-t|--threads &lt;N&gt;
    Set &lt;N&gt; as number of threads to use
-u|--unit &lt;N&gt;
    Set &lt;N&gt; as number of files processed per iteration (default 1000)
-n|--results &lt;N&gt;
    Set &lt;N&gt; as number of elements in the key map generated
</pre>
</li>

<a name="strusDumpStatistics"></a><li><b>strusDumpStatistics</b>
<br/>Dumps the statisics that would be populated to in case of a distributed index to stout.
(implemented in the project <a href="https://github.com/patrickfrey/strusUtilities">strusUtilities</a>)
<input class="toggle-box" id="strusDumpStatistics_usage" type="checkbox" >
<label for="strusDumpStatistics_usage">Usage</label>
<pre>
usage: strusDumpStatistics [options] &lt;filename&gt;
description: Dumps the statisics that would be populated 
in case of a distributed index to a file.
options:
-h|--help
    Print this usage and do nothing else
-v|--version
    Print the program version and do nothing else
-s|--storage &lt;CONFIG&gt;
    Define the storage configuration string as &lt;CONFIG&gt;
    &lt;CONFIG&gt; is a semicolon ';' separated list of assignments:
            path=&lt;LevelDB storage path&gt;
            create=&lt;yes/no, yes=do create if database does not exist yet&gt;
            cache=&lt;size of LRU cache for LevelDB&gt;
            compression=&lt;yes/no&gt;
            max_open_files=&lt;maximum number of open files for LevelDB&gt;
            write_buffer_size=&lt;Amount of data to build up in memory per file&gt;
            block_size=&lt;approximate size of user data packed per block&gt;
            cachedterms=&lt;file with list of terms to cache&gt;
-m|--module &lt;MOD&gt;
    Load components from module &lt;MOD&gt;
-M|--moduledir &lt;DIR&gt;
    Search modules to load first in &lt;DIR&gt;
-r|--rpc &lt;ADDR&gt;
    Execute the command on the RPC server specified by &lt;ADDR&gt;
-P|--statsproc &lt;NAME&gt;
    Use statistics processor with name &lt;NAME&gt;
</pre>
</li>

<a name="strusDumpStorage"></a><li><b>strusDumpStorage</b>
<br/>Dumps the statisics that would be populated to in case of a distributed index to stout.
(implemented in the project <a href="https://github.com/patrickfrey/strusUtilities">strusUtilities</a>)
<input class="toggle-box" id="strusDumpStorage_usage" type="checkbox" >
<label for="strusDumpStorage_usage">Usage</label>
<pre>
usage: strusDumpStorage [options]
description: Dumps a strus storage to stout
options:
-h|--help
    Print this usage and do nothing else
-v|--version
    Print the program version and do nothing else
-s|--storage &lt;CONFIG&gt;
    Define the storage configuration string as &lt;CONFIG&gt;
    &lt;CONFIG&gt; is a semicolon ';' separated list of assignments:
            path=&lt;LevelDB storage path&gt;
            create=&lt;yes/no, yes=do create if database does not exist yet&gt;
            cache=&lt;size of LRU cache for LevelDB&gt;
            compression=&lt;yes/no&gt;
            max_open_files=&lt;maximum number of open files for LevelDB&gt;
            write_buffer_size=&lt;Amount of data to build up in memory per file&gt;
            block_size=&lt;approximate size of user data packed per block&gt;
            cachedterms=&lt;file with list of terms to cache&gt;
-m|--module &lt;MOD&gt;
    Load components from module &lt;MOD&gt;
-M|--moduledir &lt;DIR&gt;
    Search modules to load first in &lt;DIR&gt;
-r|--rpc &lt;ADDR&gt;
    Execute the command on the RPC server specified by &lt;ADDR&gt;
-B|--blocksizes
    Dump only block sizes
-P|--prefix &lt;KEY&gt;
    Dump only the blocks of a certain type with prefix &lt;KEY&gt;
</pre>
</li>

<a name="strusRpcServer"></a><li><b>strusRpcServer</b>
<br/>Start a server processing requests from strus RPC clients<br\>
(implemented in the project <a href="https://github.com/patrickfrey/strusRpc">strusRpc</a>).
<input class="toggle-box" id="strusRpcServer_usage" type="checkbox" >
<label for="strusRpcServer_usage">Usage</label>
<pre>
strusRpcServer [options]
options:
-h|--help
    Print this usage and do nothing else
-v|--version
    Print the program version and do nothing else
-m|--module &lt;MOD&gt;
    Load components from module &lt;MOD&gt;
-M|--moduledir &lt;DIR&gt;
    Search modules to load first in &lt;DIR&gt;
-R|--resourcedir &lt;DIR&gt;
    Define a resource path &lt;DIR&gt; for the analyzer
-T|--statmsgproc &lt;NAME&gt;
    Define the message processor for statistics as &lt;NAME&gt;
-p|--port &lt;PORT&gt;
    Define the port to listen for requests as &lt;PORT&gt; (default 7181)
-s|--storage &lt;CONFIG&gt;
    Define configuration &lt;CONFIG&gt; of storage hosted by this server
-S|--configfile &lt;CFGFILE&gt;
    Define storage configuration as content of file &lt;CFGFILE&gt;
-c|--create &lt;CONFIG&gt;
    Implicitely create storage with &lt;CONFIG&gt; if it does not exist yet
-l|--logfile &lt;FILE&gt;
    Write logs to file &lt;FILE&gt;
</pre>
</li>

</div>
</div>
</body>
</html>
