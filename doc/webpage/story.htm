<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 2.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
	<link rel="icon" type="image/ico" href="images/strus.ico" />
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="Background and story of strus, a collection of C++ libraries for building a full-text search engine." />
	<meta name="keywords" content="fulltext search engine C++" />
	<meta name="author" content="Patrick Frey &lt;patrickpfrey (a) yahoo (dt) com&gt;" />
	<link rel="stylesheet" type="text/css" href="text-profile.css" title="Text Profile" media="all" />
	<title>Strus background</title>
</head>

<body>
<script type="text/javascript">
</script>
<div id="wrap">
	<div id="content">
		<h1>Strus background</h1>
		<h2>Why build yet another search engine</h2>
		<h3>Why?</h3>
		<p class="description">
		Why not?
		</p>

		<h3>Personal motivation</h3>
		<p class="description">The project <i>Strus</i> started just out of frustration. 
		I was working on a project that was doomed from the beginning for two years. 
		After realizing that it had to fail, I had to focus on finding a new job.
		Unfortunately, this proved to be more difficult than I thought. I had to do something
		to keep myself spinning and I wanted to do something on a topic that I knew by heart.
		I was working for ten years in a company providing services for information retrieval 
		and also implementing the core of the search engine for these services. So I knew 
		what it was about and the problems I had to face. In September 2014 I started the project Strus.
		</p>

		<h3>What is Strus?</h3>
		<p class="description"><i>Strus</i> is a set of components (libraries, programs,
		and language bindings)
		to build the core of a scalable full-text search engine. It aims to cover
		classical IR as well as structured search for arbitrarily complex expressions 
		on the boolean algebra of sets of term occurrences (d,p) where d references a 
		document and p a discrete position number. Besides matching of expressions,
		<i>Strus</i> also provides a mechanism to attach variables on subexpression matches
		than can be referenced in the presentation of the query result.
		</p>

		<a name="Differences"> </a>
		<h3>What distiguishes Strus from other fulltext search engines</h3>
		<a name="OutsourcingDataStore"> </a>
		<h4>Outsourcing the data storage</h4>
		<p class="description"><i>Strus</i> can be built on any modern NOSQL key/value database that has
		an <a href="http://en.wikipedia.org/wiki/Upper_and_lower_bounds">upper bound seek</a>
		to implement its data storage.
		This reduces the complexity of the problem (the <i>Strus</i> core with storage and query
		evaluation has about 32000 lines of code). Alternative implementations for the
		database can be provided by experts on the topic.</p>
		<a name="StructuredQueries"> </a>
		<h4>Modeling of structured queries</h4>
		<p class="description">
		The modeling of structured queries is more rigid than in other search engines like for
		example Lucene. This means that you can not do everything you can do with Lucene.
		<i>Strus</i> describes every structure as an N-ary operator on sets of pairs document number, position.
		The operators are implemented as iterators and can be assembled to arbitrary complex
		expression trees. The intention of this reduction is simplicity. But even with this
		simple approach, you can do most of the things you would expect to have. For example 
		seeking a phrase with a nearby operator relating to another phrase with a condition 
		that they should appear in the same sentence can be expressed easily with such expressions.
		</p>
		<a name="InformationExtraction"> </a>
		<h4>Information extraction</h4>
		<p class="description">In <i>Strus</i> the result of the set operations needed to 
		model expressions is implemented as an iterator. The advantage of this model 
		is not only that you do not need memory for storing intermediate results.
		You also do not need to care about what information to collect for an intermediate result. 
		As consequence, all information about a match is available in the moment you
		inspect the match.
		A weighting function or a summarizer can access to positions of all 
		subexpression matches without expensive introspection.
		This empowers summarization to collect information that is part of a match
		or close to a match. Hence you can implement powerful information extraction
		for feature selection or feature extraction.</p>
	</div>
</div>
</body>
</html>

